Prompt Title: URGENT: Implement Robust Two-Stage FFmpeg Preprocessing for EBML Header Fix

Current Problem:
We have correctly identified that the latest failure is due to "corrupted EBML headers in the WebM file," causing FFmpeg preprocessing to fail. This means the raw WebM generated by the browser is not immediately compatible with FFmpeg for conversion to MP4, even though Google Cloud Storage (GCS) can accept it for Video AI analysis.

Your current attempt to "preprocess the video file before uploading to Bunny.net" is necessary, but it's failing because FFmpeg itself cannot read the malformed WebM.

The Solution: Two-Stage FFmpeg Remuxing and Transcoding

To fix this reliably, the backend needs to perform a two-stage FFmpeg process on the raw WebM received from the browser:

Stage 1: WebM Header Repair (Remuxing):

Purpose: To fix the malformed EBML headers and create a clean, compliant WebM file.
Action: Immediately after receiving the raw WebM from the browser (and after it's uploaded to GCS for AI), use FFmpeg to remux its streams into a new WebM file. This copies the streams without re-encoding, often resolving header issues.
FFmpeg Command (Example):
Bash

ffmpeg -i input_raw.webm -c copy output_remuxed.webm
(Where input_raw.webm is the browser's original WebM, and output_remuxed.webm is the newly created, fixed WebM).
Logging: Crucially, log the full output and any errors from this first FFmpeg command.
Stage 2: Transcode Remuxed WebM to MP4:

Purpose: To convert the now-compliant WebM into an MP4 format that Bunny.net can reliably process.
Action: Take the output_remuxed.webm from Stage 1, and then transcode it into an MP4 file.
FFmpeg Command (Example):
Bash

ffmpeg -i output_remuxed.webm -c:v libx264 -preset medium -crf 23 -c:a aac -b:a 128k output_final.mp4
(Adjust parameters like preset, crf, b:a for desired quality/file size, but libx264 and aac are standard for MP4).
Logging: Log the full output and any errors from this second FFmpeg command.
Full Backend Pipeline (Reiteration):

Ensure your process_video_in_background (or equivalent) function now follows these steps rigorously:

Receive Raw WebM: From the browser.
Upload Raw WebM to GCS: (This is already confirmed working and is for Google Cloud Video AI).
Perform FFmpeg Stage 1 (Remux WebM): input_raw.webm -> output_remuxed.webm.
Perform FFmpeg Stage 2 (Transcode to MP4): output_remuxed.webm -> output_final.mp4.
Upload output_final.mp4 to Bunny.net Stream.
Initiate Google Cloud Video AI analysis: On the GCS-uploaded input_raw.webm.
Poll Bunny.net Stream for status: 2 (ready).
Wait for Google Cloud Video AI results.
Combine Results & Update DB: Mark video as 'approved', 'flagged', or 'failed' based on ALL pipeline successes.
Your immediate priority is to implement these two distinct FFmpeg stages to address the EBML header issue and get a valid MP4 for Bunny.net.

After implementing, please run another test and provide the complete backend logs, specifically showing the output of both FFmpeg commands, to confirm the fix.